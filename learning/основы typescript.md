JS не имеет строгих типов. В переменную можно записать что угодно. Из-за этого код является ненадежным и неудобным

* IDE не подсказывает корректно, какие параметры принимает функция
* Код может сломаться, потому что пришел не тот тип данных
* Тяжело поддерживать код, тяжело разобраться, какая переменная за что отвечает

TypeScript не является отдельным языком как таковым. Это просто надстройка над JS, позволяющая типизировать файлы

## Типизация файлов
Может быть в двух вариантах: Типы и интерфейсы

Тип или интерфейс является просто сущностью, которую задаем переменной. Синтаксис - после названия переменной через знак двоеточия определяем тип (интерфейс)

Пример
```ts
// указали, что переменная a должна являться
let a: number = 0

a = "stroka"  // даст ошибку, тк a определили как number
```

### Несколько типов
Если переменная может быть нескольких типов, используем значок "|"

```
const a: number | string = 0

a = "stroka" // ошибки не будет
a = true     // ошибка 
```

По умолчанию все тимизированными значения не являются nullable (то есть не могут быть пустыми)
Чтобы указать, что переменная может быть пустой, используется знак "?"

```
let a?: string" // переменная может быть как string, так и undefined
```

Способы объявляения

### 1. Простые типы

Существует набор базовых примитивных типов

* string
* number
* boolean

Также типом могут быть конкретные значения
```
let a: number = 1 // переменная может быть любым числом

let b: "stroka" = "stroka" // b может быть только строкой с текстом "stroka"

let c?: "blue" | "white"   // c может иметь значения только "blue", "white" или undefined
```

### 2. Интерфейс

Позволяет определить тип объекта (и только объекта). Объявляется ключевым сломом interface, и без знака = описываем поля объекта (перечисляем через ;, или вообще без него)

```
interface User {
  name: string;
  surname?: string; // ? означает что поле не обязательно
  age: number;
}

// задаем также как тип
const user: User = {
  name: "Ivan",
  age: 30,
}

// следующий вариант вызовет ошибку, тк поле name обязательно
const user2: User = {
  age: 10
}

```

Также можно задать interface напрямую без обхявления через слово interface, но так не рекомендуется делать, тк тяжело читать код (убедитесь в примере ниже)
```
let user: {
  name: string;
  age: number;
} = {
  name: "Ivan",
  age: 10
}

```


### 3. Сложные типы
Типы могут определятся ключевым словом Type, так можно записать тип в "переменную", как в примере с интерфейсом
```
// обратите внимание, что в type нужно использовать знак =
type User = {
  name: string;
  age: number;
}
```

### 4. Типизация функций
При типизации функции нужно описать все её параметры, и что она возвращает
Вариант 1 - записывать типы сразу для переменных функции (самый популярный)
```
function pow (value: number, power?: number = 2): number {
  return Math.pow(value, power)
}
```


Вариант 2 - записать в "переменную"

```
// описали тип для функции
type Pow = (value: number, power?: number = 2): number

// создаем функцию, и задаем ей тип Pow
function pow: Pow (value, power = 2) {
  return Math.pow(value, power)
}
```

Частные случаи

```
// функция ничего не принимает, ничего не возвращает
function test (): void {}

```


### Типизация массива
Для типизации массива используем []

Примеры
```
// массив из чисел
const list1: number[] = [1, 2, 3, 4]

// пустой массив (просто для примера, кейс редкий)
const list2: [] = []

// массив из одного элемента числа
const list3: [number] = [1]

// массив из элементов число или строка (оборачиваем скобочками, иначе будет число или массив строк)
const list4: (number|string)[]

interface User {
  name: string
}

// массив из пользователей
const list5: User[] 

```



## Дженерики
С помощью дженериков можно создавать сложные типы. Пока не будем подробно изучать, как их делать. Но нам придется использовать встроенные или библиотечные дженерики

Основные
* FC<T> - для создания компонента React, T - интерфейс (или тип) пропсов
* Record<T, P> - объект набор ключ-значение, T - Тип ключа, P - тип значения


```
// описываем интерфейс, какие пропсы хотим получить
interface Props {
  title: string;
}

// создаем компонент, задаем ему тип FC с пропсами
function Component: FC<Props> ({ title }) {
  return ...
}
```

По сути дженерик - тип с параметрами








